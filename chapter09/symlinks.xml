<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-config-symlinks">
  <?dbhtml filename="symlinks.html"?>

  <title>Управление устройствами</title>

  <sect2 revision="sysv">

    <title>Сетевые устройства</title>

    <para>Udev по умолчанию присваивает имена сетевым устройствам в соответствии с данными прошивки, 
	BIOS'а или физическими характеристиками, такими как шина, слот или MAC-адрес. Целью такого соглашения 
	об именовании является обеспечение того, чтобы сетевые устройства именовались последовательно, а не 
	основывались на времени обнаружения сетевой карты. Например, на компьютере с двумя сетевыми картами 
	производства Intel и Realtek сетевая карта производства Intel может стать eth0, а карта Realtek-eth1. 
	В некоторых случаях после перезагрузки, сетевые карты могут быть переименованы в другой последовательности.</para>

    <para>В новой схеме именования, типичными именами сетевых устройств являются enp5s0 или wlp3s0. Если 
	такие имена для вас нежелательны, то может быть реализована традиционная схема именования или своя собственная.</para>

    <sect3>
      <title>Отключение постоянного присвоения имен в параметрах загрузки ядра</title>

      <para>Традиционная схема именования - eth0, eth1, и так далее, может быть 
	  включена путем добавления параметра <userinput>net.ifnames=0</userinput> в командную строку ядра. 
	  Это решение подходит для систем, которые имеют только одно сетевое устройство каждого типа. В ноутбуках 
	  часто есть несколько сетевых устройств(разного типа) с именами eth0 и wlan0. Эта схема вполне применима к ним. 
	  Командная строка передается в файле конфигурации GRUB. Подробности смотрите на странице <xref linkend="grub-cfg"/>.</para>
    </sect3>

    <sect3>
      <title>Создание пользовательских правил Udev</title>

      <para>Схему именования можно настроить, создав пользовательские правила udev. В состав 
	  книги включен скрипт, который генерирует начальные правила. Чтобы их сгенерировать, 
	  выполните команду:</para>

<screen role="install"><userinput>bash /usr/lib/udev/init-net-rules.sh</userinput></screen>

      <para> Теперь, проверьте файл <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>, 
	  чтобы узнать какое имя с каким сетевым устройством сопоставлено:</para>

<screen role="nodump"><userinput>cat /etc/udev/rules.d/70-persistent-net.rules</userinput></screen>

      <note><para>В некоторых случаях, например, когда MAC-адреса были назначены
      сетевой карте вручную или в виртуальной среде, такой как Qemu или Xen,
      возможно, файл сетевых правил не будет сгенерирован, поскольку адреса
      назначаются не последовательно. В таких случаях, этот способ не применим.</para></note>

      <para>Файл начинается с блока комментариев, далее следуют две строки для каждой сетевой 
	  карты (NIC). Первая строка представляет собой описание с комментариями и содежит аппаратные 
	  идентификаторы (например, поставщик PCI и идентификаторы устройств, если это PCI-карта), а 
	  также информацию о драйвере, если его удалось обнаружить. Ни идентификатор оборудования, ни 
	  драйвер не используются для определения того, какое имя присвоить интерфейсу; эта информация 
	  предназначена только для справки. Вторая строка - это правило udev, которое соответствует 
	  этому сетевому адаптеру и фактически присваивает ему имя.</para>

      <para>Все правила udev состоят из нескольких ключей, разделенных запятыми и необязательными 
	  пробелами. Ниже приведены ключи правил и пояснения по каждому из них:</para>

      <itemizedlist>
        <listitem>
          <para><literal>SUBSYSTEM=="net"</literal> - указывает Udev игнорировать устройства, 
		  которые не явлвяются сетевыми картами..</para>
        </listitem>
        <listitem>
          <para><literal>ACTION=="add"</literal> - указывает Udev игнорировать правила для событий, 
		  отличных от добавления (события "удалить" и "изменить" также происходят, но не требуют 
		  переименования сетевых интерфейсов).</para>
        </listitem>
        <listitem>
          <para><literal>DRIVERS=="?*"</literal> - существует для того, чтобы Udev проигнорировал 
		  подинтерфейсы VLAN или моста (потому что эти подинтерфейсы не имеют драйверов). Эти подинтерфейсы 
		  пропускаются, потому что назначенные имена будут конфликтовать с именами их родительских устройств.</para>
        </listitem>
        <listitem>
          <para><literal>ATTR{address}</literal> - значением этого ключа является MAC-адрес сетевой карты.</para>
        </listitem>
        <listitem>
          <para><literal>ATTR{type}=="1"</literal> - этот ключ гарантирует выполнение правила 
		  соответствующего только основному интерфейсу, при использовании определенных беспроводных драйверов, 
		  которые создают несколько виртуальных интерфейсов. Дополнительные интерфейсы пропускаются по 
		  той же причине, что и подинтерфейсы VLAN и мост, в ином случае произошел бы конфликт имен.</para>
        </listitem>
        <listitem>
          <para><literal>NAME</literal> - значением этого ключа является имя, которое udev присвоит 
		  этому интерфейсу.</para>
        </listitem>
      </itemizedlist>

      <para>Значение <literal>NAME</literal> является очень важным. Прежде чем продолжить, убедитесь, что 
	  вы знаете, какое имя назначено каждой из сетевых карт, и обязательно используйте это значение 
	  <literal>NAME</literal> при создании файлов конфигурации далее.</para>

    </sect3>

  </sect2>

  <sect2 revision="sysv">

    <title>Символические ссылки CD-ROM</title>

    <para>Некоторое программное обеспечение, которое вы, возможно, захотите установить позже (например, 
	различные медиаплееры) ожидают, что устройства <filename class="symlink">/dev/cdrom</filename>
    или <filename class="symlink">/dev/dvd</filename> и символические ссылки на CD-ROM или DVD-ROM 
	устройства должны существовать. Кроме того, может быть удобно использовать эти символические ссылки 
	в <filename>/etc/fstab</filename>. Udev поставляется с файлом сценария, который будет генерировать 
	правила для создания этих символических ссылок, в зависимости от возможностей каждого устройства, 
	но вам нужно решить, какой из двух режимов работы вы хотите использовать.</para>

    <para>Во-первых, скрипт может работать в режиме <quote>by-path</quote> (используется по умолчанию 
	для USB и FireWire устройств), где создаваемые им правила зависят от физического пути к CD или 
	DVD устройству. Во-вторых, он может работать в режиме <quote>by-id</quote> (по умолчанию для 
	устройств IDE и SCSI), где создаваемые им правила зависят от строк идентификации, хранящихся в 
	самом устройстве CD или DVD. Путь определяется сценарием Udev <command>path_id</command>, а 
	идентификационные строки считываются с оборудования командами <command>ata_id</command> или 
	<command>scsi_id</command>, в зависимости от того, какой тип устройства у вас есть.</para>

    <para>У каждого подхода есть свои преимущества; правильный подход к использованию будет зависеть 
	от того, какие изменения устройств могут произойти. Если вы ожидаете, что физический путь к 
	устройству (порты и/или слоты, в который оно подключено), изменится, например, потому, что вы 
	планируете переместить диск в другой порт IDE или другой разъем USB, то вы должны использовать 
	режим <quote>by-id</quote>. С другой стороны, если вы ожидаете, что идентификация устройства 
	изменится, например, потому, что оно может выйти из строя, и вы замените его другим устройством 
	с теми же характеристиками и подключите к тем же разъемам, тогда вы должны использовать режим 
	<quote>by-path</quote>.</para>

    <para>Если с вашим устройством возможен любой из вариантов, выберите тот, который по вашему 
	мнению случается чаще.</para>

<!-- If you use by-id mode, the symlinks will survive even the transition
     to libata for IDE drives, but that is not for the book. -->

    <important><para>Внешние устройства (например, привод компакт-дисков, подключенный через USB) 
	не следует подключать методом <quote>by-path</quote>, потому что каждый раз, когда устройство 
	подключено в новый внешний порт, изменится его физический путь. Все внешние устройства подвержены 
	этой проблеме, если при написании правил Udev применять режим распознавания по их физическому пути. 
	К тому же, эта проблема не ограничивается CD и DVD-приводами.</para></important>

    <para>Если вы хотите увидеть значения, которые будут использовать скрипты udev, то для требуемого 
	устройства CD-ROM найдите соответствующий каталог в
    <filename class="directory">/sys</filename> (например, это может быть 
    <filename class="directory">/sys/block/hdd</filename>) и 
	выполните команду, аналогичную следующей:</para>

<screen role="nodump"><userinput>udevadm test /sys/block/hdd</userinput></screen>

    <para>Обратите внимание на строки, содержащие вывод различных идентификаторов *_id. Режим 
	<quote>by-id</quote> будет использовать значение ID_SERIAL если оно существует и не пустое, 
	иначе будет использована комбинация ID_MODEL и ID_REVISION. Режим <quote>by-path</quote> 
	будет использовать значение ID_PATH.</para>

    <para>Если режим по умолчанию не подходит для вашей ситуации, то в файл
    <filename>/etc/udev/rules.d/83-cdrom-symlinks.rules</filename> можно внести следующие 
	изменения (где <replaceable>mode</replaceable> является одним из значений 
	<quote>by-id</quote> или <quote>by-path</quote>):</para>

<screen role="nodump"><userinput>sed -e 's/"write_cd_rules"/"write_cd_rules <replaceable>mode</replaceable>"/' \
    -i /etc/udev/rules.d/83-cdrom-symlinks.rules</userinput></screen>

    <para>Обратите внимание, что на данный момент, нет необходимости создавать файлы правил 
	или символические ссылки, так как вы смонтировали каталог <filename class="directory">/dev</filename> 
	хоста в систему LFS, и мы предполагаем, что символические ссылки уже существуют. Правила и 
	символические ссылки будут создаваться при первой загрузке LFS системы.</para>

    <para>Однако, если у вас есть несколько устройств CD-ROM, то символические ссылки, 
	сгенерированные в это время, могут указывать на другие устройства, и иметь различия от хост 
	системы, потому что устройства не будут обнаружены в предсказуемом порядке. Назначения, созданные 
	при первой загрузке системы LFS, будут правильными, проблема возникнет только в том случае, если 
	символические ссылки в обеих системах указывают на одно и то же устройство. Если потребуется, 
	проверьте (и, возможно, отредактируйте) сгенерированные правила в файле 
	<filename>/etc/udev/rules.d/70-persistent-cd.rules</filename> после загрузки, чтобы убедиться, 
	что назначенные символические ссылки соответствуют тому, что вам нужно.</para>

  </sect2>

  <sect2>

    <title>Работа с дубликатами устройств</title>

    <para>Как поясняется в <xref linkend="ch-config-udev"/>, порядок отображения
    устройства с одинаковой функциональностью в <filename class="directory">/dev</filename>
    является, как правило, случайным. Например, если у вас есть веб камера и TV тюнер,
    иногда <filename>/dev/video0</filename> ссылается на камеру, а
    <filename>/dev/video1</filename> ссылается на TV тюнер, а иногда, например, после
    перезагрузки системы, порядок поменяется на противоположный. Для всех классов оборудования, 
	за исключением звуковых и сетевых карт, это можно исправить, создав правила udev для 
	пользовательских постоянных символических ссылок. Случай с сетевыми картами описан отдельно в 
	<xref linkend="ch-config-network"/>, и инструкции по настройке
    звуковых карт можно найти в <ulink url="&blfs-book;postlfs/devices.html">BLFS</ulink>.</para>

    <para>Для каждого из ваших устройств, которые могут иметь такую проблему 
	(даже если проблема не существует в текущем дистрибутиве Linux ), 
	найдите соответствующий каталог в
    <filename class="directory">/sys/class</filename> или
    <filename class="directory">/sys/block</filename>.
    Для видеоустройств это может быть
    <filename
    class="directory">/sys/class/video4linux/video<replaceable>X</replaceable></filename>.
    Определите атрибуты, которые однозначно идентифицируют устройство (обычно это идентификаторы 
	поставщика и продукта и/или серийные номера):</para>

<screen role="nodump"><userinput>udevadm info -a -p /sys/class/video4linux/video0</userinput></screen>

    <para>Затем напишите правила, которые создают символические ссылки, например:</para>

<screen role="nodump"><userinput>cat &gt; /etc/udev/rules.d/83-duplicate_devs.rules &lt;&lt; "EOF"
<literal>
# Persistent symlinks for webcam and tuner
KERNEL=="video*", ATTRS{idProduct}=="1910", ATTRS{idVendor}=="0d81", SYMLINK+="webcam"
KERNEL=="video*", ATTRS{device}=="0x036f",  ATTRS{vendor}=="0x109e", SYMLINK+="tvtuner"
</literal>
EOF</userinput></screen>

    <para>В результате устройства <filename>/dev/video0</filename> и 
	<filename>/dev/video1</filename> по-прежнему случайным образом ссылаются на TV 
	тюнер и веб-камеру (и, следовательно, никогда не должны использоваться напрямую),
    но есть символические ссылки /dev/tvtuner и /dev/webcam, которые всегда указывают
    на правильное устройство.</para>

 </sect2>

</sect1>
